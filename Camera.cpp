#include "Camera.h"

float aspect_ratio = 16.0 / 9;

// make viewport grid

Camera::Camera(int image_width)
{
	m_Position = vec3(2, 6, 4);
	m_Direction = -m_Position;
	m_fov = 45;
	m_FocalLength = 1.0;
	m_NearToFarDistance = 10.0;

	m_ImageWidth = image_width;
	m_ImageHeight = static_cast<int>((float)image_width / aspect_ratio);

	// calculate the grid dimensions here and instantiate the m_Grid bidimensional array (double pointer)
	m_Grid = (vec3**)malloc(sizeof(vec3*) * m_ImageHeight);

	if (m_Grid == NULL)
	{
		printf("error allocating pixel grid");
		return;
	}

	for (int y = 0; y < m_ImageHeight; y++)
	{
		m_Grid[y] = (vec3*)malloc(sizeof(vec3) * image_width);
	}
}

/* viewport grid and orientation according to camera position and direction
	* find camera_front: the point that's distant focal_length from the camera position on the line that has the direction of camera_direction
	* this line is the viewport plane normal, move on this plane the correct distances to find the grid's upper left corner
*/

void Camera::CreateViewportGrid()
{
	float viewport_height = 2.0;
	float viewport_width = viewport_width = viewport_height * (static_cast<double>(m_ImageWidth) / m_ImageHeight);

	vec3 world_up = vec3(0, 1, 0);

	m_Direction = unit_vector(m_Direction);

	// Ray camera_normal = Ray(m_Position, m_Direction)
	// point near_plane_origin = camera_normal.at(focal_length) = m_CameraFront
	m_CameraFront = m_Position + m_Direction * m_FocalLength;

	vec3 camera_left = unit_vector(cross(world_up, m_Direction));

	vec3 camera_up = unit_vector(cross(m_Direction, camera_left));

	// dir : (camera_left + camera_up) * (viewport_width / 2 + viewport_height / 2) + camera_front;

	// camera_front_translate is the grid upper left point on the plane generated by the camera_left and camera_up vector that passes from the origin, these point is then trnslated in front of the camera by adding m_CameraFront
	vec3 camera_front_translate = (viewport_width / 2) * camera_left + (viewport_height / 2) * camera_up;
	vec3 grid_upper_left_corner = m_CameraFront + camera_front_translate;

	float delta_u = viewport_width / m_ImageWidth;
	float delta_v = viewport_height / m_ImageHeight;

	vec3 grid_00 = grid_upper_left_corner + ((delta_u / 2) * -camera_left + (delta_v / 2) * -camera_up);

	for (int v = 0; v < m_ImageHeight; v++)
	{
		for (int u = 0; u < m_ImageWidth; u++)
		{
			vec3 pixel_center_pos = grid_00 + ((delta_u * u) * -camera_left + (delta_v * v) * -camera_up);

			m_Grid[v][u] = pixel_center_pos;
		}
	}
}

rgb Camera::SendRay(point origin, vec3 dir)
{
	Ray ray = Ray(origin, dir);

	vec3 center = vec3(0, 0, -8.0);
	float radius = 1.0;

	float t = is_hit(ray, center, radius, this);

	rgb color;

	point hit_point = ray.at(t);

	// calculate the hit_point distance from the camera's near plane
	// point plane distance formula dist = abs(a * xp + b * yp + c * zp + d) / sqrt(a ^ 2 + b ^ 2 + c ^ 2);
	// normal to the plane: n = (a, b, c), d = -(a * x0 + b * y0 + c * z0)
	// it's important to calculate the vector that passes by m_CameraFront and m_Position
	// doing just unit_vector(m_CameraFront) won't work if m_CameraFront is (0, 0, 0) and then in the point_plane_distance function dist will have a 0 denominator
	vec3 n = unit_vector(m_CameraFront - m_Position);

	float dist = Ray::point_plane_distance(m_CameraFront, n, hit_point);

	// if the hit_point is behind the far plane then don't color that pixel with the "hit color"
	//if(dist > m_NearToFarDistance)

	if (t >= 0.0 && dist < m_NearToFarDistance)
	{
		vec3 surface_normal = unit_vector(hit_point - center);
		color.r = static_cast<uint8_t>(255 * (surface_normal.x + 1) / 2);
		color.g = static_cast<uint8_t>(255 * (surface_normal.y + 1) / 2);
		color.b = static_cast<uint8_t>(255 * (surface_normal.z + 1) / 2);
	}
	else
	{
		// return white if object is not hit
		color = rgb(255, 255, 255);
	}

	return color;
}

int Camera::GetImageHeight()
{
	return m_ImageHeight;
}

vec3 Camera::GetPosition() const
{
	return m_Position;
}

vec3 Camera::GetDirection() const
{
	return m_Direction;
}

vec3** Camera::GetGrid()
{
	return m_Grid;
}

Camera::~Camera()
{
	// iterate through grid and free the rows of coordinates
	for (int v = 0; v < m_ImageHeight; v++)
	{
		free(m_Grid[v]);
	}

	free(m_Grid);
}

float is_hit(Ray ray, vec3 center, float radius, Camera* camera)
{
	vec3 oc = ray.origin() - center;

	// -oc is the line from the viewport grid pixel's coordinates to the sphere's center
	// if dot product is < 0 then the angle between the camera direction and the direction of the ray from the grid to the sphere is 90 < angle < 270
	// if the ray from grid to sphere has 90+ angle then the sphere is behind the viewport grid
	if (dot(-oc, camera->GetDirection()) < 0)
		return -1.0;

	auto a = dot(ray.direction(), ray.direction());
	auto b = 2.0 * dot(oc, ray.direction());
	auto c = dot(oc, oc) - radius * radius;
	auto discriminant = b * b - 4 * a * c;

	if (discriminant < 0)
		return -1.0;

	// return the smallest root between the two: (-b - sqrt(discriminant)) / 2a , (-b + sqrt(discriminant)) / 2a
	// so the returned t corresponds to the first hit_point on the ray (or to the only one if discr = 0 and there is a single root)
	return (-b - sqrt(discriminant)) / (2.0 * a);
}