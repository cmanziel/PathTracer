#include "Camera.h"

float aspect_ratio = 16.0 / 9;

Camera::Camera(const char* path)
	: m_ImageWidth(1000)
{
	//m_Position = vec3(5, 5, -8.5);
	m_Position = vec3(-2.0, 3.0, 5.0);
	m_Direction = -m_Position;
	//m_Direction = vec3(0.0, 0.0, -1.0);
	m_fov = 45.0;
	m_FocalLength = 1.0;
	m_NearToFarDistance = 99.0;

	m_ImageHeight = static_cast<int>((double)m_ImageWidth / aspect_ratio);

	m_tInterval = Interval(0.0, infinity);

	m_ImagePath = path;

	m_ImageData = AllocPNGDatastream();

	if (m_ImageData == NULL)
		throw std::exception("image data not allocated\n");

	// calculate the grid dimensions here and instantiate the m_Grid bidimensional array (double pointer)
	m_Grid = (vec3**)malloc(sizeof(vec3*) * m_ImageHeight);

	if (m_Grid == NULL)
	{
		throw std::exception("viewport grid not allocated\n");
	}

	for (int y = 0; y < m_ImageHeight; y++)
	{
		m_Grid[y] = (vec3*)malloc(sizeof(vec3) * m_ImageWidth);

		if (m_Grid[y] == NULL)
		{
			// if the current row is not allocated, free the ones allocated before and throw an exception
			for (int j = 0; j < y; j++)
				free(m_Grid[y]);

			throw std::exception("viewport grid not allocated\n");
		}
	}
}

/* viewport grid and orientation according to camera position and direction
	* find camera_front: the point that's distant focal_length from the camera position on the line that has the direction of camera_direction
	* this line is the viewport plane normal, move on this plane the correct distances to find the grid's upper left corner
*/

unsigned char* Camera::AllocPNGDatastream()
{
	// loop through grid, sent ray through every pixel, color the pixel
	int row_size = CHANNELS_PER_PIXEL * m_ImageWidth + 1; // 1 byte for filter method
	int pixel_data_size = row_size * m_ImageHeight * sizeof(unsigned char);
	unsigned char* pixel_data = (unsigned char*)malloc(pixel_data_size);

	return pixel_data;
}


void Camera::CreateViewportGrid()
{
	double viewport_height = 2.0;
	double viewport_width = viewport_width = viewport_height * (static_cast<double>(m_ImageWidth) / m_ImageHeight);

	vec3 world_up = vec3(0, 1, 0);

	m_Direction = unit_vector(m_Direction);

	// Ray camera_normal = Ray(m_Position, m_Direction)
	// point near_plane_origin = camera_normal.at(focal_length) = m_CameraFront
	m_CameraFront = m_Position + m_Direction * m_FocalLength;

	vec3 camera_left = unit_vector(cross(world_up, m_Direction));

	vec3 camera_up = unit_vector(cross(m_Direction, camera_left));

	// dir : (camera_left + camera_up) * (viewport_width / 2 + viewport_height / 2) + camera_front;

	// camera_front_translate is the grid upper left point on the plane generated by the camera_left and camera_up vector that passes from the origin, these point is then trnslated in front of the camera by adding m_CameraFront
	vec3 camera_front_translate = (viewport_width / 2) * camera_left + (viewport_height / 2) * camera_up;
	vec3 grid_upper_left_corner = m_CameraFront + camera_front_translate;

	double delta_u = viewport_width / m_ImageWidth;
	double delta_v = viewport_height / m_ImageHeight;

	vec3 grid_00 = grid_upper_left_corner + ((delta_u / 2) * -camera_left + (delta_v / 2) * -camera_up);

	for (int v = 0; v < m_ImageHeight; v++)
	{
		for (int u = 0; u < m_ImageWidth; u++)
		{
			vec3 pixel_center_pos = grid_00 + ((delta_u * u) * -camera_left + (delta_v * v) * -camera_up);

			m_Grid[v][u] = pixel_center_pos;
		}
	}
}

void Camera::Render(std::vector<Hittable*> world)
{
	int row_size = CHANNELS_PER_PIXEL * m_ImageWidth + 1; // 1 byte for filter method
	for (unsigned int y = 0; y < m_ImageHeight; y++)
	{
		unsigned int row_start = y * row_size;
		unsigned char filter_method = 0x00;

		m_ImageData[row_start] = filter_method;

		for (int x = 0; x < m_ImageWidth; x++)
		{
			point rayOrigin = m_Grid[y][x];
			vec3 dir = rayOrigin - m_Position;

			Ray ray(rayOrigin, dir);

			hit_record hitData;
			rgb color;

			// problem for all the objects it has to be checked if the ray interescted one of them, and which of them is closer

			hit_record closest;
			double smallest_t = 0.0;
			bool hit_anything = false;

			for (Hittable* obj : world)
			{
				if (obj->Hit(ray, m_tInterval, hitData))
				{
					hit_anything = true;

					if (hitData.t < smallest_t || smallest_t == 0.0)
					{
						smallest_t = hitData.t;
						closest = hitData;
					}
				}

				// if nothing was hit set the bcakground color for this pixel's color
				if (!hit_anything)
					color = rgb(255, 255, 255);
				else
				{
					color.r = static_cast<uint8_t>(255 * (closest.normal.x + 1) / 2);
					color.g = static_cast<uint8_t>(255 * (closest.normal.y + 1) / 2);
					color.b = static_cast<uint8_t>(255 * (closest.normal.z + 1) / 2);
				}
			}

			unsigned int index = y * row_size + CHANNELS_PER_PIXEL * x + 1;

			m_ImageData[index] = color.r; index++;
			m_ImageData[index] = color.g; index++;
			m_ImageData[index] = color.b; index++;
		}
	}

	m_Image = create_image(m_ImageData, m_ImagePath, m_ImageWidth, m_ImageHeight);
}

int Camera::GetImageHeight()
{
	return m_ImageHeight;
}

vec3 Camera::GetPosition() const
{
	return m_Position;
}

vec3 Camera::GetDirection() const
{
	return m_Direction;
}

vec3** Camera::GetGrid() const
{
	return m_Grid;
}

double Camera::GetFocalLength() const
{
	return m_FocalLength;
}

double Camera::GetFarPlaneDistance() const
{
	return m_FocalLength + m_NearToFarDistance;
}

Camera::~Camera()
{
	// iterate through grid and free the rows of coordinates
	for (int v = 0; v < m_ImageHeight; v++)
	{
		free(m_Grid[v]);
	}

	free(m_Grid);

	free(m_ImageData);
	fclose(m_Image);
}